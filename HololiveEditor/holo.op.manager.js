/********************************	hololive op manager **********************************/const VERSION = 0.2; // OBJECTSvar opArray = new Array();var tarray1 = new Array();var tarray2 = new Array();var conArray = new Array();var inputobj = this.patcher.getnamed('holo.input');var outputobj = this.patcher.getnamed('holo.output');var patchname = 'holo.op.';// GRAPHICSvar startx = 0;var starty = 83;var opheight = 75;var opwidth = 300;var opspace = 2;var outheight = 235;var minopnum = 3;var outputobj_miny = starty + (opheight +opspace) * minopnum;var outputobj_y = outputobj_miny;// IDsvar unique = 1950;var count = 0;var g;if(jsarguments.length > 1)	setunique(jsarguments[1]);function init(){	/* del connections */	if(inputobj && outputobj)		this.patcher.disconnect(inputobj,0,outputobj,0);}function setunique(i){	unique = i;	g = new Global(unique+"global");	//post("setting_unique ");	//post(unique);	//post();}function op_add(){	if (arguments.length < 2)		return;	var  obj;	var args = new Array(startx,starty,opwidth,opheight,0,0);	var opname = arguments[1];	var applymode  = arguments[0];	var objname = 'op'+(count++);	args[6] = patchname+opname;	args[7] = 521;	args[8] = unique;	args[9] = objname;	args[10] = applymode;	args[11] = opname;		for (i=2;i<arguments.length;i++)		args[i+10] = arguments[i];	obj = this.patcher.newobject("bpatcher",args);	obj.varname = objname;	//post(args);		if(obj)		opArray[opArray.length] = obj;		op_update();}// function op_add_at_name(name)// {// 	i=op_search(name);// 	if(i != -1)// 	{// 		g.opnum = i;// 		g.sendnamed(unique+"_op_rem_dialog","opnum");// 	}// }function op_add_at(){	if (arguments.length < 3)			return;	var ind=op_search(arguments[0]);	//post(" "+ind);	//post(arguments[0]);	//post();	if(ind != -1)	{				var  obj;		var args = new Array(startx,starty,opwidth,opheight,0,0);		var opname = arguments[2];		var applymode  = arguments[1];		var objname = 'op'+(count++);			args[6] = patchname+opname;		args[7] = 521;		args[8] = unique;		args[9] = objname;		args[10] = applymode;		args[11] = opname;				for (i=3;i<arguments.length;i++)			args[i+10] = arguments[i];			obj = this.patcher.newobject("bpatcher",args);		obj.varname = objname;		//post(args);				if(obj)		{			if(ind == opArray.length - 1)			{				opArray[opArray.length] = obj;			}			else{				opArray.splice(ind+1,0,obj);				//insert(opArray,ind,obj);				//post(opArray);				//post();			}		}		op_update();			}}function op_update(){	op_reconnect();	move_outobj();	op_redisplay();}function move_outobj(){	r = new Array();	if(opArray.length > minopnum)		outputobj_y = starty + (opheight +opspace) * opArray.length;	else		outputobj_y = outputobj_miny;			r[0] = startx;	r[1] = outputobj_y;	r[2] = startx+opwidth;	r[3] = outputobj_y+outheight;	outputobj.rect = r;}function op_redisplay(){	for(i=0;i<opArray.length;i++)	{		op_move(opArray[i],startx,starty + i *(opheight+opspace));	}}function op_disconnect(){	var o1,o2;	for(i=0;i<conArray.length;i++)	{		if((o1 = conArray[i][0]) && (o2 = conArray[i][1]))		{			this.patcher.disconnect(o1,0,o2,0);		}	}	conArray.length = 0;}function op_reconnect(){	var o1,o2;	op_disconnect();	if(opArray.length == 0)	{		con_add(inputobj,0,outputobj,0);	}	else	{		o1 =inputobj;		for(i=0;i<opArray.length;i++)		{			o2 = opArray[i];			con_add(o1,0,o2,0);			o1 = o2;		}		con_add(o1,0,outputobj,0);	}}function op_move(obj,x,y){	r = new Array();	r[0] = x;	r[1] = y;	r[2] = x+opwidth;	r[3] = y+opheight;	obj.rect = r;}function op_clear(){	for(i=0;i<opArray.length;i++)	{		this.patcher.remove(opArray[i]);	}	opArray.length = 0;		op_update();}function op_rem_dialog(name){	i=op_search(name);	if(i != -1)	{		g.opnum = i;		g.sendnamed(unique+"_op_rem_dialog","opnum");	}}function op_rem(name){	i=op_search(name);	if(i != -1)	{		this.patcher.remove(opArray[i]);		opArray.splice(i,1);		op_update();	}}function op_rem_last(){	l = opArray.length;	if(l>0)	{		this.patcher.remove(opArray[l-1]);		opArray.splice(l-1,1);		op_update();	}}function op_replace(){	if (arguments.length < 3)			return;	op_add_at(arguments[0],arguments[1],arguments[2]);	op_rem(arguments[0]);}function op_search(name){	for(i=0;i<opArray.length;i++)	{		if(opArray[i].varname == name)			return i;	}	return -1;}function op_bang_preset(){	for(i=0;i<opArray.length;i++)	{		g.oname = opArray[i].varname;		g.sendnamed(unique+"_bang_preset","oname");	}}// UTILITYfunction insert(ar,i,obj){	if( i>=0 ) {	  var a = ar.slice(), b = a.splice( i );	  a[i] = v;	  return a.concat( b );	 }	}function con_add(o1,i,o2,i){	if(o1 && o2)	{		this.patcher.connect(o1,i,o2,i);		conArray.push([o1,o2]);	}}function disconnect_safe(o1,i,o2,i){	this.patcher.connect(o1,i,o2,i);	this.patcher.disconnect(o1,i,o2,i);}